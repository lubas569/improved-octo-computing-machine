#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <assert.h>
#include <algorithm>

int64_t r(int64_t min, int64_t max) {
    int64_t n1 = rand();
    int64_t n2 = rand();
    int64_t n3 = rand();
    n1 = n1 ^ (n2 << 16) ^ (n3 << 16);
    n1 = n1 % (max - min);
    n1 = n1 + min;
    return n1;
}

int64_t sdiv(int64_t a, int64_t b) {
  return (a - ((a % b) + b) % b) / b;
}

bool u_method_0(int den, int sh_post, int bits) {
    uint64_t max = (1L << bits) - 1;
    //for (int64_t num = 0; num <= max; num++) {
    for (unsigned iter = 0; iter < 1000000UL; iter++) {
        uint64_t num = r(0, max);
        // Make sure we hit the extremes
        if (iter == 0) num = 0;
        if (iter == 1) num = max;
	uint64_t result = num;
	result >>= sh_post;
	if (num / den != result) return false;
    }
    return true;
}

bool u_method_1(int den, int64_t mul, int sh_post, int bits) {
    uint64_t max = (1L << bits) - 1;
    //for (uint64_t num = 0; num <= max; num++) {
    for (unsigned iter = 0; iter < 1000000UL; iter++) {
        uint64_t num = r(0, max);
        // Make sure we hit the extremes
        if (iter == 0) num = 0;
        if (iter == 1) num = max;
	uint64_t result = num;
	result *= mul;
	result >>= bits;
	if (result > max) return false;
	result >>= sh_post;
	if (num / den != result) return false;
    }
    return true;
}

bool u_method_2(int den, int64_t mul, int sh_post, int bits) {
    uint64_t max = (1UL << bits) - 1;
    //for (uint64_t num = 0; num <= max; num++) {
    for (unsigned iter = 0; iter < 1000000UL; iter++) {
        uint64_t num = r(0, max);
        // Make sure we hit the extremes
        if (iter == 0) num = 0;
        if (iter == 1) num = max;
	uint64_t result = num;
	result *= mul;
	result >>= bits;
	if (result > max) return false;
	result += (num - result)>>1;
	if (result > max) return false;
	result >>= sh_post;
	if (num / den != result) return false;
    }
    return true;
}

bool s_method_0(int den, int sh_post, int bits) {
    int64_t min = -(1L << (bits-1)), max = (1L << (bits-1))-1;
    //for (int64_t num = min; num <= max; num++) {
    for (int iter = 0; iter < 1000000L; iter++) {
        int64_t num = r(min, max);
        // Make sure we hit the extremes
        if (iter == 0) num = min;
        if (iter == 1) num = max;
        int64_t result = num;
	result >>= sh_post;
	if (sdiv(num, den) != result) return false;
    }
    return true;
}

bool s_method_1(int den, int64_t mul, int sh_post, int bits) {
    int64_t min = -(1 << (bits-1)), max = (1 << (bits-1))-1;

    //for (int64_t num = min; num <= max; num++) {
    for (int iter = 0; iter < 1000000L; iter++) {
        int64_t num = r(min, max);
        // Make sure we hit the extremes
        if (iter == 0) num = min;
        if (iter == 1) num = max;
	int64_t result = num;
        uint64_t xsign = result >> (bits-1);
        uint64_t q0 = (mul * (xsign ^ result)) >> bits;
        result = xsign ^ (q0 >> sh_post);
	if (sdiv(num, den) != result) return false;
    }
    return true;
}

int main(int argc, char **argv) {
    /* This program computes a table to help us do cheap integer
        division by a constant. It is based on the paper "Division by
        Invariant Integers using Multiplication" by Granlund and
        Montgomery.
    */

    printf("/** \\file \n"
           " * Tables telling us how to do integer division\n"
           " * via fixed-point multiplication for various small\n"
           " * constants. This file is automatically generated\n"
           " * by find_inverse.c. There are two sets of tables.\n"
           " * The first set is for compile-time-constant divisors\n"
           " * from 2 to 256. The second is for runtime divisors\n"
           " * from 1 to 255. The second set always uses the most\n"
           " * expensive method, while the compile-time set uses\n"
           " * the cheapest method for the given divisor.\n"
           " */\n"
           "#include <stdint.h>\n"
           "namespace Halide {\n"
           "namespace Internal {\n"
           "namespace IntegerDivision {\n\n");

    for (int runtime = 0; runtime < 2; runtime++) {
        for (int bits = 8; bits <= 32; bits *= 2) {
            if (runtime) {
                printf("int64_t table_runtime_u%d[][4] = {\n", bits);
            } else {
                printf("int64_t table_u%d[][4] = {\n", bits);
            }
            for (int d = 0; d < 256; d++) {
                int den = d;
                if (den == 0) den = 256;
                if (!runtime) {
                    for (int shift = 0; shift < 16; shift++) {
                        if (u_method_0(den, shift, bits)) {
                            printf("    {%d, 0, 0, %d},\n", den, shift);
                            goto next_unsigned;
                        }
                    }

                    for (int shift = 0; shift < 8; shift++) {
                        int64_t mul = (1L << (bits+shift)) / den + 1;
                        if (u_method_1(den, mul, shift, bits)) {
                            printf("    {%d, 1, %ldULL, %d},\n", den, mul, shift);
                            goto next_unsigned;
                        }
                    }
                }

                for (int shift = 0; shift < 8; shift++) {
                    int64_t mul = (1L << (bits+shift+1)) / den - (1L << bits) + 1;
                    if (u_method_2(den, mul, shift, bits)) {
                        printf("    {%d, 2, %ldULL, %d},\n", den, mul, shift);
                        goto next_unsigned;
                    }
                }
                printf("ERROR! No solution found for unsigned %d\n", den);
              next_unsigned:;
            }
            printf("};\n");
            if (runtime) {
                printf("int64_t table_runtime_s%d[][4] = {\n", bits);
            } else {
                printf("int64_t table_s%d[][4] = {\n", bits);
            }
            for (int d = 0; d <= 256; d++) {
                int den = d;
                if (den == 0) den = 256;
                if (!runtime) {
                    for (int shift = 0; shift < 8; shift++) {
                        if (s_method_0(den, shift, bits)) {
                            printf("    {%d, 0, 0, %d},\n", den, shift);
                            goto next_signed;
                        }
                    }
                }

                for (int shift = 0; shift < 8; shift++) {
                    int64_t mul = (1L << (shift + bits)) / den + 1;
                    if (s_method_1(den, mul, shift, bits)) {
                        printf("    {%d, 1, %ldLL, %d},\n", den, mul, shift);
                        goto next_signed;
                    }
                }
                printf("ERROR! No solution found for signed %d\n", den);
              next_signed:;
            }
            printf("};\n");
        }
    }

    printf("}}}\n");

    return 0;
}
